/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef, useState } from "react";
import { useGLTF } from "@react-three/drei";
import { useFrame } from "@react-three/fiber";

export function Pokeball(props) {
  const { nodes, materials } = useGLTF("./pokeball.glb");
  const pokeballRef = useRef();
  const { setShowText } = props;

  // Button
  const buttonRef = useRef();
  const buttonOriginalZ = useRef(null);

  // Lid
  const topRef = useRef();
  const topClosedRotation = useRef(null);
  const topTargetRotation = useRef(null);
  const topOriginalZ = useRef(null);

  const handleButtonClick = () => {
    if (!buttonRef.current) return;

    setShowText(true);

    // Button Position

    if (buttonOriginalZ.current === null) {
      buttonOriginalZ.current = buttonRef.current.position.z;
    }

    buttonRef.current.position.z = buttonOriginalZ.current - 0.02;

    setTimeout(() => {
      if (!buttonRef.current) return;
      buttonRef.current.position.z = buttonOriginalZ.current;
    }, 120);

    // Top Opening

    if (topClosedRotation.current === null) {
      topClosedRotation.current = topRef.current.rotation.x;
      topOriginalZ.current = topRef.current.position.z;
    }

    topTargetRotation.current = topClosedRotation.current - Math.PI / 3;
    topRef.current.position.z = topOriginalZ.current - 0.2;
  };

  useFrame((state) => {
    const time = state.clock.elapsedTime;

    // Float up and down
    pokeballRef.current.position.y = Math.sin(time) * 0.2;

    // Rotate to face corners
    pokeballRef.current.rotation.x = Math.sin(time * 0.5) * 0.25; // up / down
    pokeballRef.current.rotation.y = Math.cos(time * 0.5) * 0.25; // left / right
  });

  useFrame(() => {
    if (!topRef.current || topTargetRotation.current === null) return;

    // Smoothly move toward target
    topRef.current.rotation.x +=
      (topTargetRotation.current - topRef.current.rotation.x) * 0.1;
  });

  const handleClosePokeball = () => {
    if (!topRef.current) return;

    topTargetRotation.current = topClosedRotation.current;
    topRef.current.position.z = topOriginalZ.current;
  };

  return (
    <group ref={pokeballRef} {...props} dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.bottom.geometry}
        material={materials.white}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.mid.geometry}
        material={materials.black}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.top.geometry}
        material={materials.red}
        ref={topRef}
        onClick={handleClosePokeball}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cylinder.geometry}
        material={materials.black}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cylinder_1.geometry}
        material={materials.white}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cylinder001.geometry}
        material={materials.white}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cylinder001_1.geometry}
        material={materials.button}
        ref={buttonRef}
        onClick={handleButtonClick}
      />
    </group>
  );
}

useGLTF.preload("./pokeball.glb");
